# [70. Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)
Easy

You are climbing a staircase. It takes n steps to reach the top.

Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?

 

Example 1:
```
Input: n = 2
Output: 2
Explanation: There are two ways to climb to the top.
1. 1 step + 1 step
2. 2 steps
```
Example 2:
```
Input: n = 3
Output: 3
Explanation: There are three ways to climb to the top.
1. 1 step + 1 step + 1 step
2. 1 step + 2 steps
3. 2 steps + 1 step
 ```

Constraints:

- 1 <= n <= 45

## Approach
```
- Problem effectively becomes fibonacci
```

## Solution
```java
class Solution {
    public int climbStairs(int n) {
       int dp[] = new int[n + 1];
       return dp(n, dp);
    }

    public int dp(int n, int[] dp) {
        if(n == 1) return dp[n] = 1;
        if(n == 2) return dp[n] = 2;

        int oneStep = dp(n - 1, dp);
        int twoStep = dp(n - 2, dp);
        
        return dp[n] = oneStep + twoStep;
    }
}
```

## Solution
```java
class Solution {
    public int climbStairs(int n) {
        int one = 1, two = 1;
        for(int i = 2; i <= n; i++) {
            int tmp = one;
            one = one + two;
            two = tmp;
        }
        return one;
    }
}
```



## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(1)
```
---
# [746. Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)
Easy


You are given an integer array cost where cost[i] is the cost of ith step on a staircase. Once you pay the cost, you can either climb one or two steps.

You can either start from the step with index 0, or the step with index 1.

Return the minimum cost to reach the top of the floor.

 

Example 1:
```
Input: cost = [10,15,20]
Output: 15
Explanation: You will start at index 1.
- Pay 15 and climb two steps to reach the top.
The total cost is 15.
```
Example 2:
```
Input: cost = [1,100,1,1,1,100,1,1,100,1]
Output: 6
Explanation: You will start at index 0.
- Pay 1 and climb two steps to reach index 2.
- Pay 1 and climb two steps to reach index 4.
- Pay 1 and climb two steps to reach index 6.
- Pay 1 and climb one step to reach index 7.
- Pay 1 and climb two steps to reach index 9.
- Pay 1 and climb one step to reach the top.
The total cost is 6.
 ```

Constraints:

- 2 <= cost.length <= 1000
- 0 <= cost[i] <= 999


## Solution
```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] memo = new int[cost.length];
        return Math.min(helper(cost, cost.length - 1, memo), helper(cost, cost.length - 2, memo));
    }
    
      private int helper(int[] cost, int i, int[] memo) {
        if (i < 0) return 0;
        if (i == 0 || i == 1) return cost[i]; // Base cases

        if (memo[i] > 0) return memo[i];

        memo[i] = cost[i] + Math.min(helper(cost, i - 1, memo), helper(cost, i - 2, memo));
        return memo[i];
    }
}

```
---
# [198. House Robber](https://leetcode.com/problems/house-robber/)
Medium

You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

 

Example 1:
```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```
Example 2:
```
Input: nums = [2,7,9,3,1]
Output: 12
Explanation: Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1).
Total amount you can rob = 2 + 9 + 1 = 12.
 ```

Constraints:

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 400

## Approach
```
Pattern:
for loop
  dp[i] = max(dp[i-1], nums[i]+dp[i-2]); 
- either take the amount till previous element or else add current element to the amount till pre previous elements 
```
## Solution

```java
  public int rob(int[] nums) {
        int[] memo = new int[nums.length];
        java.util.Arrays.fill(memo, -1); // Fill with -1 as default uncomputed value
        return helper(nums, nums.length - 1, memo);
    }

    private int helper(int[] nums, int i, int[] memo) {
        if (i < 0) return 0;

        if (memo[i] != -1) return memo[i];

        int robCurrent = nums[i] + helper(nums, i - 2, memo);
        int skipCurrent = helper(nums, i - 1, memo);
        memo[i] = Math.max(robCurrent, skipCurrent);

        return memo[i];
    }
```

```java
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1)
            return nums[0];
        int[] dp = new int[n];
        dp[0] = nums[0];
        dp[1] = Math.max(nums[0], nums[1]);
        for(int i = 2; i < n; i++) {
            dp[i] = Math.max(dp[i-1], nums[i]+dp[i-2]);
        }
        
        return dp[n-1];
    }
    
}
```

```java
  // optimized
class Solution {
    public int rob(int[] nums) {
        int n = nums.length;
        if(n == 1)
            return nums[0];
        int prev2 = nums[0];
        int prev1 = Math.max(nums[0], nums[1]);
        
        for(int i = 2; i < n; i++) {
            int temp = prev1;
            prev1 = Math.max(prev1, nums[i]+prev2);
            prev2 = temp;
        }
        return prev1;
    } 
}
```
## Complexity Analysis
```
1st solution:
  - Time Complexity: O(N)
  - Space Complexity: O(N)
2nd solution:
  - Time Complexity: O(N)
  - Space Complexity: O(1)
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity O(1)
```
---
# [213. House Robber II](https://leetcode.com/problems/house-robber-ii/)
Medium


You are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are arranged in a circle. That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and it will automatically contact the police if two adjacent houses were broken into on the same night.

Given an integer array nums representing the amount of money of each house, return the maximum amount of money you can rob tonight without alerting the police.

 

Example 1:
```
Input: nums = [2,3,2]
Output: 3
Explanation: You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses.
```
Example 2:
```
Input: nums = [1,2,3,1]
Output: 4
Explanation: Rob house 1 (money = 1) and then rob house 3 (money = 3).
Total amount you can rob = 1 + 3 = 4.
```
Example 3:
```
Input: nums = [1,2,3]
Output: 3
 ```

Constraints:

- 1 <= nums.length <= 100
- 0 <= nums[i] <= 1000

## Approach

## Solution
```java
public class HouseRobberII {
    public int rob(int[] nums) {
        if (nums.length == 1) return nums[0];

        return Math.max(robHelper(nums, 0, nums.length - 2), robHelper(nums, 1, nums.length - 1));
    }

    private int robHelper(int[] nums, int start, int end) {
        int[] memo = new int[nums.length];
        java.util.Arrays.fill(memo, -1); // Fill with -1 as default uncomputed value
        return helper(nums, end, memo, start);
    }

    private int helper(int[] nums, int i, int[] memo, int start) {
        if (i < start) return 0;

        if (memo[i] != -1) return memo[i];

        int robCurrent = nums[i] + helper(nums, i - 2, memo, start);
        int skipCurrent = helper(nums, i - 1, memo, start);
        memo[i] = Math.max(robCurrent, skipCurrent);

        return memo[i];
    }

    public static void main(String[] args) {
        HouseRobberII hr = new HouseRobberII();
        int[] nums = {2, 3, 2};
        System.out.println(hr.rob(nums)); // Output: 3
    }
}

```
## Complexity Analysis
```
- Time Complexity: O(2 * N) ~ O(N)
```
---
# 5. Longest Palindromic Substring
Medium


Given a string s, return the longest palindromic substring in s.

 
Example 1:
```
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```
Example 2:
```
Input: s = "cbbd"
Output: "bb"
``` 

Constraints:

- 1 <= s.length <= 1000
- s consist of only digits and English letters.


## Solution
```java
class Solution {
    
    static class AnsPair {
        int maxValue = Integer.MIN_VALUE;
        String ans = "";

    }
    
    public static String palindromeSubString(String str, int[][] dp) {
        int count = 0;
        AnsPair ansPair = new AnsPair();
        int n = str.length();
        for(int g = 0; g < n; g++) {
            for(int i = 0, j = g; j < n; i++, j++) {

                    if(g == 0) {
                       dp[i][j] = 1;
                   }else if(g == 1) {
                       dp[i][j] = (str.charAt(i) == str.charAt(j)) ? 2 : 0;
                   } else {
                       if(str.charAt(i) == str.charAt(j) && dp[i+1][j-1] != 0) 
                           dp[i][j] = dp[i+1][j-1] + 2;
                       else
                           dp[i][j] = 0;     

                   }
                    
                    if(dp[i][j] > ansPair.maxValue) {
                        ansPair.maxValue = dp[i][j];
                        ansPair.ans = str.substring(i, j + 1);
                    }
                }
        }
        return ansPair.ans;
    }
    
    public String longestPalindrome(String str) {
        int n = str.length();
        int dp[][] = new int[n][n];
        for(int[] rowDp : dp) {
            Arrays.fill(rowDp, -1);
        }
        return palindromeSubString(str, dp);
        
    }
}
```

## Complexity Analysis
```
- Time Complexity:
  - Approach 1: O(N*N)
  - Approach 2: O(N)
- Space Complexity:
  - Approach 1: O(1)
  - Approach 2: O(N)
```
