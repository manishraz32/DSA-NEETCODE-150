# 206. Reverse Linked List

Given the head of a singly linked list, reverse the list, and return the reversed list.


Example 1:

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```
Example 2:

```
Input: head = [1,2]
Output: [2,1]
```
Example 3:
```
Input: head = []
Output: []
 ```

Constraints:

- The number of nodes in the list is the range [0, 5000].
- -5000 <= Node.val <= 5000
 

### Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode curr = head, next = head, prev = null;
        
        while(curr != null) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        
        return prev;
    }
}
```
---

# 21. Merge Two Sorted Lists
Easy

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

 
```
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```
```
Example 2:
Input: list1 = [], list2 = []
Output: []
```
```
Example 3:
Input: list1 = [], list2 = [0]
Output: [0]
 ```

Constraints:

The number of nodes in both lists is in the range [0, 50].
-100 <= Node.val <= 100
Both list1 and list2 are sorted in non-decreasing order.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode result = dummy;
        while(list1 != null && list2 != null) {
            if(list1.val < list2.val) {
                dummy.next = list1;
                dummy = dummy.next;
                list1 = list1.next;
            } else {
                dummy.next = list2;
                dummy = dummy.next;
                list2 = list2.next;
            }       
        }
        
        if(list1 != null) {
            dummy.next = list1;
        }
        
        if(list2 != null) {
            dummy.next = list2;
        }
        
        return result.next;
    }
}
```
---
# 143. Reorder List
Medium


You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - 1 → Ln
Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
You may not modify the values in the list's nodes. Only nodes themselves may be changed.

 

Example 1:
```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```
Example 2:
```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
 ```

Constraints:

- The number of nodes in the list is in the range [1, 5 * 104].
- 1 <= Node.val <= 1000

## Approach
```
- Reverse the other half(mid to end)
- 2 pointers one from the head other from the reverse head of other list
- use temp variable to keep the next pointers of both the list
- 1st list's next points to 2nd list & 2nd list's next point to the temp variable containing the next of the 1st list
- move both the pointers 
```

## Solution
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
     public static ListNode midNode(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode slow = node, fast = node;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public static ListNode reverseList(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode prev = null;
        ListNode curr = node;
        while (curr != null) {
            ListNode forw = curr.next; // backup.

            curr.next = prev; // connection

            prev = curr; // move forw.
            curr = forw;
        }

        return prev;
    }
    public void reorderList(ListNode head) {
         if (head == null || head.next == null)
            return;

        ListNode mid = midNode(head);
        ListNode nhead = mid.next;
        mid.next = null;

        nhead = reverseList(nhead);

        ListNode c1 = head;
        ListNode c2 = nhead;

        while (c1 != null && c2 != null) {
            ListNode f1 = c1.next;
            ListNode f2 = c2.next;

            c1.next = c2;
            c2.next = f1;

            c1 = f1;
            c2 = f2;
        }
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(2*N) ~ O(N)
- Space Complexity: O(1)
```
---
# 19. Remove Nth Node From End of List
Medium


Given the head of a linked list, remove the nth node from the end of the list and return its head.

 

Example 1:
```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```
Example 2:
```
Input: head = [1], n = 1
Output: []
```
Example 3:
```
Input: head = [1,2], n = 1
Output: [1]
 ```

Constraints:

The number of nodes in the list is sz.
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz
 

### Follow up: Could you do this in one pass?

## Approach
```
- 2 pointers approach
- dummy head for so that removing head would be easier 
- fast pointer would be ahead by n nodes
- slow and fast will start moving until fast reach the last element
- slow's next node would be the one we need to remove
```

## Solution
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
         if(head == null) return head;
        ListNode slow = head;
        ListNode fast = head;
        while(n-- > 0) {
            System.out.println(n);
            fast = fast.next;
        }
        if(fast == null) {
            ListNode rnode = slow;
            head = rnode.next;
            rnode.next = null;
            return head;
            
        }
        while(fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }
        ListNode rnode = slow.next;
        slow.next = rnode.next;
        rnode.next = null;
        return head;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N) , one pass only
- Space Complexity: O(1)
```
