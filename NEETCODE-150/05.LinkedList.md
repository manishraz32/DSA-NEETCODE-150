# 206. Reverse Linked List

Given the head of a singly linked list, reverse the list, and return the reversed list.


Example 1:

```
Input: head = [1,2,3,4,5]
Output: [5,4,3,2,1]
```
Example 2:

```
Input: head = [1,2]
Output: [2,1]
```
Example 3:
```
Input: head = []
Output: []
 ```

Constraints:

- The number of nodes in the list is the range [0, 5000].
- -5000 <= Node.val <= 5000
 

### Follow up: A linked list can be reversed either iteratively or recursively. Could you implement both?

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode curr = head, next = head, prev = null;
        
        while(curr != null) {
            next = curr.next;
            curr.next = prev;
            prev = curr;
            curr = next;
        }
        
        return prev;
    }
}
```
---

# 21. Merge Two Sorted Lists
Easy

You are given the heads of two sorted linked lists list1 and list2.

Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.

Return the head of the merged linked list.

 
```
Example 1:
Input: list1 = [1,2,4], list2 = [1,3,4]
Output: [1,1,2,3,4,4]
```
```
Example 2:
Input: list1 = [], list2 = []
Output: []
```
```
Example 3:
Input: list1 = [], list2 = [0]
Output: [0]
 ```

Constraints:

The number of nodes in both lists is in the range [0, 50].
-100 <= Node.val <= 100
Both list1 and list2 are sorted in non-decreasing order.

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummy = new ListNode(0);
        ListNode result = dummy;
        while(list1 != null && list2 != null) {
            if(list1.val < list2.val) {
                dummy.next = list1;
                dummy = dummy.next;
                list1 = list1.next;
            } else {
                dummy.next = list2;
                dummy = dummy.next;
                list2 = list2.next;
            }       
        }
        
        if(list1 != null) {
            dummy.next = list1;
        }
        
        if(list2 != null) {
            dummy.next = list2;
        }
        
        return result.next;
    }
}
```
---
# 143. Reorder List
Medium


You are given the head of a singly linked-list. The list can be represented as:

L0 → L1 → … → Ln - 1 → Ln
Reorder the list to be on the following form:

L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …
You may not modify the values in the list's nodes. Only nodes themselves may be changed.

 

Example 1:
```
Input: head = [1,2,3,4]
Output: [1,4,2,3]
```
Example 2:
```
Input: head = [1,2,3,4,5]
Output: [1,5,2,4,3]
 ```

Constraints:

- The number of nodes in the list is in the range [1, 5 * 104].
- 1 <= Node.val <= 1000

## Approach
```
- Reverse the other half(mid to end)
- 2 pointers one from the head other from the reverse head of other list
- use temp variable to keep the next pointers of both the list
- 1st list's next points to 2nd list & 2nd list's next point to the temp variable containing the next of the 1st list
- move both the pointers 
```

## Solution
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
     public static ListNode midNode(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode slow = node, fast = node;
        while (fast.next != null && fast.next.next != null) {
            slow = slow.next;
            fast = fast.next.next;
        }
        return slow;
    }

    public static ListNode reverseList(ListNode node) {
        if (node == null || node.next == null)
            return node;

        ListNode prev = null;
        ListNode curr = node;
        while (curr != null) {
            ListNode forw = curr.next; // backup.

            curr.next = prev; // connection

            prev = curr; // move forw.
            curr = forw;
        }

        return prev;
    }
    public void reorderList(ListNode head) {
         if (head == null || head.next == null)
            return;

        ListNode mid = midNode(head);
        ListNode nhead = mid.next;
        mid.next = null;

        nhead = reverseList(nhead);

        ListNode c1 = head;
        ListNode c2 = nhead;

        while (c1 != null && c2 != null) {
            ListNode f1 = c1.next;
            ListNode f2 = c2.next;

            c1.next = c2;
            c2.next = f1;

            c1 = f1;
            c2 = f2;
        }
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(2*N) ~ O(N)
- Space Complexity: O(1)
```
---
# 19. Remove Nth Node From End of List
Medium


Given the head of a linked list, remove the nth node from the end of the list and return its head.

 

Example 1:
```
Input: head = [1,2,3,4,5], n = 2
Output: [1,2,3,5]
```
Example 2:
```
Input: head = [1], n = 1
Output: []
```
Example 3:
```
Input: head = [1,2], n = 1
Output: [1]
 ```

Constraints:

The number of nodes in the list is sz.
- 1 <= sz <= 30
- 0 <= Node.val <= 100
- 1 <= n <= sz
 

### Follow up: Could you do this in one pass?

## Approach
```
- 2 pointers approach
- dummy head for so that removing head would be easier 
- fast pointer would be ahead by n nodes
- slow and fast will start moving until fast reach the last element
- slow's next node would be the one we need to remove
```

## Solution
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
         if(head == null) return head;
        ListNode slow = head;
        ListNode fast = head;
        while(n-- > 0) {
            System.out.println(n);
            fast = fast.next;
        }
        if(fast == null) {
            ListNode rnode = slow;
            head = rnode.next;
            rnode.next = null;
            return head;
            
        }
        while(fast.next != null) {
            slow = slow.next;
            fast = fast.next;
        }
        ListNode rnode = slow.next;
        slow.next = rnode.next;
        rnode.next = null;
        return head;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N) , one pass only
- Space Complexity: O(1)
```
---
# 138. Copy List with Random Pointer
Medium


A linked list of length n is given such that each node contains an additional random pointer, which could point to any node in the list, or null.

Construct a deep copy of the list. The deep copy should consist of exactly n brand new nodes, where each new node has its value set to the value of its corresponding original node. Both the next and random pointer of the new nodes should point to new nodes in the copied list such that the pointers in the original list and copied list represent the same list state. None of the pointers in the new list should point to nodes in the original list.

For example, if there are two nodes X and Y in the original list, where X.random --> Y, then for the corresponding two nodes x and y in the copied list, x.random --> y.

Return the head of the copied linked list.

The linked list is represented in the input/output as a list of n nodes. Each node is represented as a pair of `[val, random_index]` where:

- `val: an integer representing Node.val`
- `random_index: the index of the node (range from 0 to n-1) that the random pointer points to, or null if it does not point to any node.`

Your code will only be given the head of the original linked list.

 

Example 1:
```
Input: head = [[7,null],[13,0],[11,4],[10,2],[1,0]]
Output: [[7,null],[13,0],[11,4],[10,2],[1,0]]
```
Example 2:
```
Input: head = [[1,1],[2,1]]
Output: [[1,1],[2,1]]
```
Example 3:
```
Input: head = [[3,null],[3,0],[3,null]]
Output: [[3,null],[3,0],[3,null]]
 ```

Constraints:

- 0 <= n <= 1000
- -10<sup>4</sup> <= Node.val <= 10<sup>4</sup>
- `Node.random` is null or is pointing to some node in the linked list.

## Approach
```
- Step 1: Duplicate each node such that old1->new1->old2->new2 ...
- Step 2: Random pointer of new = Random pointer of old's next
- Step 3: Seperate the the nodes to form old1->old2.. & new1->new2..
```

## Solution
```java
/*
// Definition for a Node.
class Node {
    int val;
    Node next;
    Node random;

    public Node(int val) {
        this.val = val;
        this.next = null;
        this.random = null;
    }
}
*/
 public static Node cloneLL(Node head) {
        Node temp = head;
        // Create a HashMap to map original nodes
        // to their corresponding copied nodes
        HashMap<Node, Node> map = new HashMap<>();

        // Step 1: Create copies of each
        // node and store them in the map
        while (temp != null) {
            // Create a new node with the
            // same data as the original node
            Node newNode = new Node(temp.data);
            // Map the original node to its
            // corresponding copied node in the map
            map.put(temp, newNode);
            // Move to the next node in the original list
            temp = temp.next;
        }

        temp = head;
        // Step 2: Connect the next and random
        // pointers of the copied nodes using the map
        while (temp != null) {
            // Access the copied node corresponding
            // to the current original node
            Node copyNode = map.get(temp);
            // Set the next pointer of the copied node
            // to the copied node mapped to the
            // next node in the original list
            copyNode.next = map.get(temp.next);
            // Set the random pointer of the copied node
            // to the copied node mapped to the
            // random node in the original list
            copyNode.random = map.get(temp.random);
            // Move to the next node in the original list
            temp = temp.next;
        }

        // Return the head of the
        // deep copied list from the map
        return map.get(head);
    }
```
---
# 2. Add Two Numbers
Medium


You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

 

Example 1:
```
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```
Example 2:
```
Input: l1 = [0], l2 = [0]
Output: [0]
```
Example 3:
```
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
 ```

Constraints:

- The number of nodes in each linked list is in the range [1, 100].
- 0 <= Node.val <= 9
- It is guaranteed that the list represents a number that does not have leading zeros.

## Approach
```
- Three pointers, one for each given list and 3rd one for resultant list
- untill both the pointers pointing to given lists are null or carry > 0
  - add new node to the resultant list
```

## Solution
```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
        ListNode res = new ListNode(0);
        ListNode curr1 = l1, curr2 = l2, curr3 = res;
        int carry = 0;
        while(curr1 != null || curr2 != null || carry > 0) {
            int v1 = curr1 == null ? 0 : curr1.val;
            int v2 = curr2 == null ? 0 : curr2.val;
            int sum = v1 + v2 + carry;
            carry = sum / 10;
            curr3.next = new ListNode(sum % 10);
            curr3 = curr3.next;
            curr1 = curr1 == null ? curr1 : curr1.next;
            curr2 = curr2 == null ? curr2 : curr2.next;
        }

        return res.next;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(max(len(list1, list2))
- Space Complexity: O(max(len(list1, list2))
```

