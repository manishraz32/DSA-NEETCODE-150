# [226. Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)
Given the root of a binary tree, invert the tree, and return its root.

 ```
Example 1:
Input: root = [4,2,7,1,3,6,9]
Output: [4,7,2,9,6,3,1]
```
```
Example 2:
Input: root = [2,1,3]
Output: [2,3,1]
```
```
Example 3:
Input: root = []
Output: []
```

Constraints:
- The number of nodes in the tree is in the range [0, 100].
- -100 <= Node.val <= 100

## Approach
```
- Recursion
- store one pointer to right or left subtree
- swap left with right and make call recursively
```

## Solution
```java
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode() {}
 *     TreeNode(int val) { this.val = val; }
 *     TreeNode(int val, TreeNode left, TreeNode right) {
 *         this.val = val;
 *         this.left = left;
 *         this.right = right;
 *     }
 * }
 */
  public TreeNode invertTree(TreeNode root) {
       if(root == null) return null;
       TreeNode temp = root.left;
       root.left = root.right;
       root.right = temp;
       invertTree(root.left);
       invertTree(root.right);

       return root;
  }
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(H), atmost height of tree would be the number of recursive call stack at a given point of time
```
---
# 104. Maximum Depth of Binary Tree

Given the root of a binary tree, return its maximum depth.

A binary tree's maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.

```
Example 1:
Input: root = [3,9,20,null,null,15,7]
Output: 3
```
```
Example 2:
Input: root = [1,null,2]
Output: 2
```

Constraints:
- The number of nodes in the tree is in the range [0, 104].
- -100 <= Node.val <= 100

## Approach
```
- Recursion
- if node = null return 0
- return 1 + max(leftHeight, rightHeight)
```

## Solution
```java
class Solution {
    public int maxDepth(TreeNode root) {
        if(root == null) return 0;
        int leftDepth = maxDepth(root.left);
        int rightDepth = maxDepth(root.right);
        return Math.max(leftDepth, rightDepth) + 1;
    }
}
```

## Complexity Analysis
```
- Time Complexity: O(N)
- Space Complexity: O(H), height of the tree
```
---
# 543. Diameter of Binary Tree
Easy

Given the root of a binary tree, return the length of the diameter of the tree.

The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.

The length of a path between two nodes is represented by the number of edges between them.


Example 1:
```
Input: root = [1,2,3,4,5]
Output: 3
Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3].
```

Example 2:
```
Input: root = [1,2]
Output: 1
 ```

Constraints:
- The number of nodes in the tree is in the range [1, 104].
- -100 <= Node.val <= 100

```java
class Solution {
    public int diameterOfBinaryTree(TreeNode root) {
        int[] max = new int[1];
        diameter(root, max);
        return max[0];
    }
    public int diameter(TreeNode root, int[] max) {
        if(root == null) return 0;
        
        int leftHeight = diameter(root.left, max);
        int rightHeight = diameter(root.right, max);
        max[0] = Math.max(max[0], leftHeight + rightHeight);

        return 1 + Math.max(leftHeight, rightHeight);
    }
}
```
---
# 110. Balanced Binary Tree
Easy

Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as:

a binary tree in which the left and right subtrees of every node differ in height by no more than 1.

 

Example 1:
```
Input: root = [3,9,20,null,null,15,7]
Output: true
```

Example 2:
```
Input: root = [1,2,2,3,3,null,null,4,4]
Output: false
```

Example 3:
```
Input: root = []
Output: true
```

Constraints:
- The number of nodes in the tree is in the range [0, 5000].
- -104 <= Node.val <= 104

```java
class Solution {
    public boolean isBalanced(TreeNode root) {
        if(root == null) return true;
        int height = height(root);
        return height == -1 ? false : true;
    }

    public int height(TreeNode root) {
        if(root == null) return 0;
        int lh = height(root.left);
        int rh = height(root.right);
        if(lh == -1 || rh == -1) return -1;
        if(Math.abs(lh - rh) > 1) return -1;
        return Math.max(lh, rh) + 1;
    }

}
```
---
# 100. Same Tree
Easy

Given the roots of two binary trees p and q, write a function to check if they are the same or not.

Two binary trees are considered the same if they are structurally identical, and the nodes have the same value.

 

Example 1:
```
Input: p = [1,2,3], q = [1,2,3]
Output: true
```

Example 2:
```
Input: p = [1,2], q = [1,null,2]
Output: false
```

Example 3:
```
Input: p = [1,2,1], q = [1,1,2]
Output: false
 ```

Constraints:
- The number of nodes in both trees is in the range [0, 100].
- -104 <= Node.val <= 104

```java
class Solution {
    public boolean isSameTree(TreeNode p, TreeNode q) {
        if(p == null && q == null) return true;
        if(p == null && q != null) return false;
        if(p != null && q == null) return false;
        if(p.val != q.val) return false;
        boolean left = isSameTree(p.left, q.left);
        boolean right = isSameTree(p.right, q.right);

        return left && right;
    }
}
```
---
# 572. Subtree of Another Tree
Easy

Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.

A subtree of a binary tree tree is a tree that consists of a node in tree and all of this node's descendants. The tree tree could also be considered as a subtree of itself.

 

Example 1:
```
Input: root = [3,4,5,1,2], subRoot = [4,1,2]
Output: true
```

Example 2:
```
Input: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2]
Output: false
 ```

Constraints:
- The number of nodes in the root tree is in the range [1, 2000].
- The number of nodes in the subRoot tree is in the range [1, 1000].
- -104 <= root.val <= 104
- -104 <= subRoot.val <= 104

```java

class Solution {
    public boolean isIdentical(TreeNode root1, TreeNode root2) {
        if(root1 == null && root2 == null) {
            return true;
        }
        if(root1 == null || root2 == null) {
            return false;
        }
        if(root1.val != root2.val) {
            return false;
        }
        boolean lans = isIdentical(root1.left, root2.left);
        boolean rans = isIdentical(root1.right, root2.right);
        return lans && rans;
    }
    public boolean isSubtree(TreeNode root, TreeNode subRoot) {
        LinkedList<TreeNode> que = new LinkedList<>();
        que.add(root);
        while(que.size() > 0) {
            TreeNode revNode = que.removeFirst();
            
            if(revNode.val == subRoot.val) {
                if(isIdentical(revNode, subRoot)) {
                    return true;
                }
            }
            
            if(revNode.left != null) que.add(revNode.left);
            if(revNode.right != null) que.add(revNode.right);
        }
        return false;
    }
}

```
---
# 235. Lowest Common Ancestor of a Binary Search Tree
Easy


Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

 

Example 1:
```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
```
Example 2:
```
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
```
Example 3:
``
Input: root = [2,1], p = 2, q = 1
Output: 2
 ``

Constraints:

- The number of nodes in the tree is in the range `[2, 105]`.
- -10<sup>9</sup> <= Node.val <= 10<sup>9</sup>
- All Node.val are unique.
- p != q
- p and q will exist in the BST.

## Approach
```
- Recursion
- if root's val < p's val & q's val then reduce the problem to right subtree of root
- else if root's val > p's val & q's val then reduce the problem to left subtree of root
- else return root (if p's val or q's val equal to root's val or for p & q lies in different subtree of the root)
```

## Solution
```java

class Solution {
    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        if(root == null)
            return null;
        int val = root.val;
        if(val < p.val && val < q.val)
            return lowestCommonAncestor(root.right, p, q);
        else if(val > p.val && val > q.val)
            return lowestCommonAncestor(root.left, p, q);
        return root;
    }
}
```
```java
 public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {
        while(root != null) {
            if(p.val < root.val && q.val < root.val) {
                root = root.left;
            } else if (p.val > root.val && q.val > root.val) {
                root = root.right;
            } else {
                return root;
            }
        }
        return null;
 }
```
## Complexity Analysis
```
- Time Complexity: O(logN)
- Space Complexity: O(logN) recursive calls
```
